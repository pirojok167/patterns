### Итератор

### Назначение
Итератор обеспечивает перебор элементов коллекции без раскрытия её реализации.

### Проблема

У нас есть коллекция [художественной литературы](FictionList.java),
которая реализована с помощью `ArrayList`. Так же у нас есть коллекция [документальной литературы](NonfictionList.java),
которая реализована с помощью обычного массива `T[]`. Книги в коллекциях при этом одинаковые и имеют тип [Book](Book.java).

Нам необходимо вывести на экран названия книг из обоих списков. Поскольку одна коллекция реализована как массив,
а другая как список - их не получится проитерировать вместе. А если итерировать их по-отдельности,
то в случае появления новой коллекции книг, нам придется добавлять ещё один цикл.

### Решение

Попробуем абстрагироваться от реализаций каждой конкретной коллекции.
Наш метод вывода книг на экран не должен знать с какой коллекцией он работает, поэтому он должен принимать интерфейс .
Мы можем сами создать такой интерфейс [Iterator](Iterator.java), либо же воспользоваться готовым, который уже предоставляет нам *Java* - `java.util.Iterator`.

Добавим имплементацию этого интерфейса для художественных книг [NonfictionIterator](NonfictionIterator.java).
В методах `hasNext()` и `next()` пропишем логику работы с нашей коллекцией.
Итератор для коллекции с документальными книгами реализовывать не нужно, т.к. он уже предоставляется из коробки для типа `ArrayList`.

Далее нам необходимо гарантировать наличие генератора у каждой коллекции, которую хотим проитерировать.
Для этого создадим интерфейс [BookAggregator](BookAggregator.java) и наследуем наши коллекции от него.
Данный интерфейс предоставляет метод `createIterator()`, который будет создавать соответствующий итератор для коллекции.

Таким образом мы реализовали паттерн итератор. Многие интерфейсы для реализации данного паттерна уже предоставляются языком.
А многие встроенные коллекции, такие как `List` уже содержат реализацию итератора.
