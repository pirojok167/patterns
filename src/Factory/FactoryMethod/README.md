# Фабричный метод

Рассмотрим пример [Простой фабрики](../SimpleFactory).
Мы можем расширить наш код, заменив простую фабрику [SimplePizzaFactory](../SimpleFactory/SimplePizzaFactory.java)
на несколько разных фабрик, которые отвечают за создание определённой группы объектов.

Например, в Русскую пиццу добавляют больше майонеза, а в китайскую больше перца.
Теперь вместо [SimplePizzaFactory](../SimpleFactory/SimplePizzaFactory.java) у нас есть две фабрики
[ChinesePizzaFactory](InflexibleFactoryExample/ChinesePizzaFactory.java) и [RussianPizzaFactory](InflexibleFactoryExample/RussianPizzaFactory.java),
которые мы прокидываем в наш класс [PizzaStore](PizzaStore.java).

Выглядит здорово! Но что делать, если появятся ещё классы (магазины), которые захотят использовать наши фабрики?
В таком случае возникнет проблема с процессами по приготовлению пиццы. В одном классе-пиццерии пропустят вызов метода *bake()*,
в другом классе два раза вызовут метод *cut()* и т.п.

Как решить эту проблему? Ответ очевиден - стандартизировать процесс приготовления пиццы, при этом сохранив гибкость.

Попробуем вынести эти процессы в абстрактный общий класс [PizzaStore.makePizza()](PizzaStore.java),
чтобы у всех пиццерий был одинаковый процесс приготовления пиццы.

Далее предоставим пиццериям самим решать какую пиццу готовить.
Для этого, вместо использования сторонних классов-фабрик, мы добавим метод `createPizza()` каждому субклассу (магазину),
который создаёт необходимый магазину объект-пиццу. Этот метод диктуется интерфейсом или абстрактным классом [PizzaStore](PizzaStore.java),
поэтому всегда будет в каждом субклассе-пиццерии.

Теперь у каждого магазина абсолютно одинаковые процессы приготовления пиццы,
и при этом каждый из них умеет готовить свою специфичную для региона пиццу, благодаря методу `createPizza()`.

Таким образом мы создали метод-фабрику, в честь чего этот паттерн и называется - `фабричный метод`.
