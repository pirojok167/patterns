# Состояние

### Цель
Помогает управлять поведением объекта при изменении его состояния.

### Проблема
Классический пример: есть старый будильник с парой физических кнопок, а иногда и вовсе с одной.
Нажатие на кнопку один раз переведёт будильник в режим настройки часов.
При втором нажатии будильник перейдёт в режим установки времени сигнала будильника.
При ещё одном нажатии будильник вернётся в своё начальное состояние - просто отображать время.
Кнопка одна, а состояний несколько.

Если мы попробуем реализовать будильник в лоб, то у нас получится куча условных конструкций.
При появлении ещё одного состояния нам придётся изменять уже существующий работающий код, что нарушает принцип `Open/Closed`.

Воспользуемся паттерном `State` для решения нашей задачи.

### Решение

У нас есть три состояния будильника и одно действие (нажатие на кнопку), которое может привести к переходу из одного состояния в другое.
Давайте вынесем каждое состояние в отдельный класс: [отображение времени](ShowTime.java), [настройка времени](SettingTime.java) и [настройка будильника](SettingAlarm.java).
Действие же будет реализовано в методе `pressButton()` у абсолютно каждого класса-состояния, и чтобы гарантировать его наличие у всех состояний - добавим интерфейс [State](State.java).

Далее реализуем класс самого [будильника (контекст)](Alarm.java) и добавим ему метод нажатия на кнопку, который в свою очередь будет вызывать `pressButton()` у классов-состояний.
Будильник будет сам хранить своё состояние в приватном свойстве `state`, а в конструкторе укажем его начальное состояние - [отображение текущего времени](ShowTime.java).

Проверим как работает будильник.
Нажатие кнопки вызовет метод `pressButton()` у текущего состояния, то есть у [ShowTime](ShowTime.java).
Это действие приведёт к смене состояния и на экране будильника отобразится [режим настройки времени](SettingTime.java).
Каждый раз нажимая кнопку состояние будет меняться и на экране будет выводиться соответствующий режим.

### Примечание

Действие не всегда переводит автомат из одного состояния в другое, оно может что-то выполнять, но состояние останется прежним.

Состояния можно изменять не внутри самих классов-состояний, а из контекста.
Если переходы между состояниями статичны, то рекомендуется менять состояния из контекста.
Если же переходы динамичны - лучше размещать их в самом классе состоянии.
Главное, чтобы классы состояния сами не хранили состояние.

Паттерн `State` очень похож на паттерн `Strategy`.
Они оба выносят логические операции наружу с помощью композиции, а диаграммы классов у них идентичны.
Но цели у паттернов абсолютно разные. Так же огромное отличие в том,
что в паттерне `Strategy` поведение жёстко настраивается при инициализации объекта, а в паттерне `State`
оно может меняться динамически в процессе выполнения кода.