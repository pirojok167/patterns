# Middleware

### Описание
Паттерн middleware, в других проявлениях так же - цепочка обязанностей.
Middleware - это буквально промежуточный функционал, который необходим, чтобы что-то сделать с потоком данных,
где эти данные по цепочке передаются от одного обработчика - другому, последовательно.
Частый пример это middleware для http запросов. Когда приходит запрос, и мы по цепочке вызываем различные middleware'ы.
Например, логирование запроса, валидация, десериализация и т.д.

### Цель
Последовательные действия с данными. Благодаря паттерну функционал легко расширяется,
очень просто добавляются и удаляются обработчики.

### Реализация
У этого паттерна есть множество разных реализаций, но в целом они очень похожи, и суть у них одна и та же.

В качестве примера создадим цепочку middleware'ов для запроса [Request](Request.java).
У нас есть главный обработчик [BusinessLogic](BusinessLogic.java), который возвращает [Response](Response.java).
Этот обработчик будет вызываться после прохождения всех middleware'ов.
Он реализует интерфейс [Handler](Handler.java). Этот обработчик не обязателен, но чаще всего он есть.

Давайте создадим несколько middleware'ов: [Logger](Logger.java) и [Validator](Validator.java).
Они реализуют интерфейс [Middleware](Middleware.java).

Ну и самый главный класс - [Pipeline](Pipeline.java).
Он так же везде называется по-разному, но суть его в одном - вызывать обработчики.
В этом объекте будет храниться список обработчиков, включая главный обработчик, который вызовется в конце.

Есть разные реализации последовательного вызова, например, когда в каждом middleware'е хранится ссылка на следующий.
Таким образом каждый middleware просто внутри себя вызывает следующий, как `связанный список`.
В моём случае мы передаём `callback`, то есть метод `handle` самого пайплайна.
И внутри middleware'ов будет рекурсивно вызываться этот метод, пока не закончатся middleware'ы.

Почему [Pipeline](Pipeline.java) реализует интерфейс [Handler](Handler.java)?
И почему [Middleware](Middleware.java) вторым параметром принимает интерфейс [Handler](Handler.java)?
Потому что в java стрелочные функции это просто методы анонимных классов, которые реализуют какой-то интерфейс.
Даже если мы пишем стрелочную функцию, она всё равно преобразуется в объект с одним методом, который и вызывается.
В других языках можно сделать гораздо проще, просто передавать функцию и не указывать интерфейс [Handler](Handler.java).