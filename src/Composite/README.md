# Компоновщик

### Назначение
Паттерн позволяет работать с древовидной структурой данных как с однородным объектом.
Мы можем применять одни и те же операции как к листьям, так и к узлам дерева (композитам) одинаково.

### Пример

#### Проблема
У нас есть [библиотека](Library.java) - корневой узел дерева (root node). В библиотеке куча разных [книг](Book.java), которые относятся к разным жанрам.
Каждый жанр это коллекция определённых книг, то есть внутренний узел в древовидной структуре.
А книга - конечный объект или листовой узел (leaf node).
Нам необходимо распечатать названия всех книг и коллекций - жанров.
Как это сделать, если у нас два разных класса для листьев и узлов?

#### Решение

Для простоты используем в качестве композита не внутренние узлы - жанры книг, а просто один корневой узел - саму [библиотеку](Library.java).

Все узлы и листья являются компонентами. Создадим [абстрактный класс](Component.java) компонента и унаследуем его.
Книги, как и библиотека реализуют только те методы, которые им нужны. То есть книги реализуют метод `getPrice()`,
а библиотека переопределяет `add()` и `remove`. Но оба компонента реализуют метод операции `print()`.

В методе `print()` [книги](Book.java) просто выводят на экран своё название. А [библиотека](Library.java), помимо вывода названия,
также итерирует свою коллекцию книг, и вызывает у каждой книги этот же метод операции `print()`.

В конечном итоге мы смогли проитерировать всё дерево и вывести на экран как коллекцию книг, так и сами книги.

### Принципы
Данный паттерн нарушает принцип `SRP`, так как компонент имеет две обязанности, то есть наследуется двумя разными классами - библиотекой и отдельными книгами. 
Но благодаря этому мы имеем полную прозрачность работы с деревом.

Конечно, мы можем разделить класс на два интерфейса, отделить композиты от листовых узлов.
Но в таком случае нам придётся писать дополнительные проверки типа `instanseOf` или `isComposite()` и т.п.